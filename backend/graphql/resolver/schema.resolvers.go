package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"time"

	"github.com/mmcdole/gofeed"
	"undef.ninja/x/feedaka/db"
	gql "undef.ninja/x/feedaka/graphql"
	"undef.ninja/x/feedaka/graphql/model"
)

// AddFeed is the resolver for the addFeed field.
func (r *mutationResolver) AddFeed(ctx context.Context, url string) (*model.Feed, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch the feed to get its title
	fp := gofeed.NewParser()
	feed, err := fp.ParseURL(url)
	if err != nil {
		return nil, fmt.Errorf("failed to parse feed: %w", err)
	}

	// Insert the feed into the database
	dbFeed, err := r.Queries.CreateFeed(ctx, db.CreateFeedParams{
		Url:       url,
		Title:     feed.Title,
		FetchedAt: time.Now().UTC().Format(time.RFC3339),
		UserID:    userID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to insert feed: %w", err)
	}

	// Insert articles from the feed
	for _, item := range feed.Items {
		_, err = r.Queries.CreateArticle(ctx, db.CreateArticleParams{
			FeedID: dbFeed.ID,
			Guid:   item.GUID,
			Title:  item.Title,
			Url:    item.Link,
			IsRead: 0,
		})
		if err != nil {
			// Log but don't fail on individual article errors
			fmt.Printf("Failed to insert article: %v\n", err)
		}
	}

	return &model.Feed{
		ID:           strconv.FormatInt(dbFeed.ID, 10),
		URL:          dbFeed.Url,
		Title:        dbFeed.Title,
		FetchedAt:    dbFeed.FetchedAt,
		IsSubscribed: dbFeed.IsSubscribed == 1,
	}, nil
}

// UnsubscribeFeed is the resolver for the unsubscribeFeed field.
func (r *mutationResolver) UnsubscribeFeed(ctx context.Context, id string) (bool, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	feedID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, fmt.Errorf("invalid feed ID: %w", err)
	}

	// Check if feed exists and belongs to user
	feed, err := r.Queries.GetFeed(ctx, db.GetFeedParams{
		ID:     feedID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return false, fmt.Errorf("feed not found or access denied")
		}
		return false, fmt.Errorf("failed to query feed: %w", err)
	}

	err = r.Queries.UnsubscribeFeed(ctx, feed.ID)
	if err != nil {
		return false, fmt.Errorf("failed to unsubscribe from feed: %w", err)
	}

	return true, nil
}

// MarkArticleRead is the resolver for the markArticleRead field.
func (r *mutationResolver) MarkArticleRead(ctx context.Context, id string) (*model.Article, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	articleID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid article ID: %w", err)
	}

	// Check if article exists and belongs to user
	article, err := r.Queries.GetArticle(ctx, db.GetArticleParams{
		ID:     articleID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("article not found or access denied")
		}
		return nil, fmt.Errorf("failed to query article: %w", err)
	}

	// Update the article's read status
	err = r.Queries.UpdateArticleReadStatus(ctx, db.UpdateArticleReadStatusParams{
		IsRead: 1,
		ID:     article.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to mark article as read: %w", err)
	}

	// Fetch the updated article
	return r.Query().Article(ctx, id)
}

// MarkArticleUnread is the resolver for the markArticleUnread field.
func (r *mutationResolver) MarkArticleUnread(ctx context.Context, id string) (*model.Article, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	articleID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid article ID: %w", err)
	}

	// Check if article exists and belongs to user
	article, err := r.Queries.GetArticle(ctx, db.GetArticleParams{
		ID:     articleID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("article not found or access denied")
		}
		return nil, fmt.Errorf("failed to query article: %w", err)
	}

	// Update the article's read status
	err = r.Queries.UpdateArticleReadStatus(ctx, db.UpdateArticleReadStatusParams{
		IsRead: 0,
		ID:     article.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to mark article as unread: %w", err)
	}

	// Fetch the updated article
	return r.Query().Article(ctx, id)
}

// MarkFeedRead is the resolver for the markFeedRead field.
func (r *mutationResolver) MarkFeedRead(ctx context.Context, id string) (*model.Feed, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	feedID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid feed ID: %w", err)
	}

	// Check if feed exists and belongs to user
	feed, err := r.Queries.GetFeed(ctx, db.GetFeedParams{
		ID:     feedID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("feed not found or access denied")
		}
		return nil, fmt.Errorf("failed to query feed: %w", err)
	}

	// Update all articles in the feed to be read
	err = r.Queries.MarkFeedArticlesRead(ctx, feed.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to mark feed as read: %w", err)
	}

	// Fetch the updated feed
	return r.Query().Feed(ctx, id)
}

// MarkFeedUnread is the resolver for the markFeedUnread field.
func (r *mutationResolver) MarkFeedUnread(ctx context.Context, id string) (*model.Feed, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	feedID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid feed ID: %w", err)
	}

	// Check if feed exists and belongs to user
	feed, err := r.Queries.GetFeed(ctx, db.GetFeedParams{
		ID:     feedID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("feed not found or access denied")
		}
		return nil, fmt.Errorf("failed to query feed: %w", err)
	}

	// Update all articles in the feed to be unread
	err = r.Queries.MarkFeedArticlesUnread(ctx, feed.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to mark feed as unread: %w", err)
	}

	// Fetch the updated feed
	return r.Query().Feed(ctx, id)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	// Verify user credentials
	user, err := r.Queries.GetUserByUsername(ctx, username)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("invalid credentials")
		}
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	// Verify password
	if !verifyPassword(user.PasswordHash, password) {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Get Echo context to create session
	echoCtx, err := getEchoContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get echo context: %w", err)
	}

	// Create session and store user ID
	if err := r.SessionConfig.SetUserID(echoCtx, user.ID); err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:       strconv.FormatInt(user.ID, 10),
			Username: user.Username,
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Get Echo context to destroy session
	echoCtx, err := getEchoContext(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to get echo context: %w", err)
	}

	// Destroy session
	if err := r.SessionConfig.DestroySession(echoCtx); err != nil {
		return false, fmt.Errorf("failed to destroy session: %w", err)
	}

	return true, nil
}

// Feeds is the resolver for the feeds field.
func (r *queryResolver) Feeds(ctx context.Context) ([]*model.Feed, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	dbFeeds, err := r.Queries.GetFeeds(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query feeds: %w", err)
	}

	var feeds []*model.Feed
	for _, dbFeed := range dbFeeds {
		feeds = append(feeds, &model.Feed{
			ID:           strconv.FormatInt(dbFeed.ID, 10),
			URL:          dbFeed.Url,
			Title:        dbFeed.Title,
			FetchedAt:    dbFeed.FetchedAt,
			IsSubscribed: dbFeed.IsSubscribed == 1,
		})
	}

	return feeds, nil
}

// UnreadArticles is the resolver for the unreadArticles field.
func (r *queryResolver) UnreadArticles(ctx context.Context) ([]*model.Article, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	rows, err := r.Queries.GetUnreadArticles(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query unread articles: %w", err)
	}

	var articles []*model.Article
	for _, row := range rows {
		articles = append(articles, &model.Article{
			ID:     strconv.FormatInt(row.ID, 10),
			FeedID: strconv.FormatInt(row.FeedID, 10),
			GUID:   row.Guid,
			Title:  row.Title,
			URL:    row.Url,
			IsRead: row.IsRead == 1,
			Feed: &model.Feed{
				ID:           strconv.FormatInt(row.FeedID2, 10),
				URL:          row.FeedUrl,
				Title:        row.FeedTitle,
				IsSubscribed: row.FeedIsSubscribed == 1,
			},
		})
	}

	return articles, nil
}

// ReadArticles is the resolver for the readArticles field.
func (r *queryResolver) ReadArticles(ctx context.Context) ([]*model.Article, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	rows, err := r.Queries.GetReadArticles(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query read articles: %w", err)
	}

	var articles []*model.Article
	for _, row := range rows {
		articles = append(articles, &model.Article{
			ID:     strconv.FormatInt(row.ID, 10),
			FeedID: strconv.FormatInt(row.FeedID, 10),
			GUID:   row.Guid,
			Title:  row.Title,
			URL:    row.Url,
			IsRead: row.IsRead == 1,
			Feed: &model.Feed{
				ID:           strconv.FormatInt(row.FeedID2, 10),
				URL:          row.FeedUrl,
				Title:        row.FeedTitle,
				IsSubscribed: row.FeedIsSubscribed == 1,
			},
		})
	}

	return articles, nil
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, id string) (*model.Feed, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	feedID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid feed ID: %w", err)
	}

	dbFeed, err := r.Queries.GetFeed(ctx, db.GetFeedParams{
		ID:     feedID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("feed not found")
		}
		return nil, fmt.Errorf("failed to query feed: %w", err)
	}

	return &model.Feed{
		ID:           strconv.FormatInt(dbFeed.ID, 10),
		URL:          dbFeed.Url,
		Title:        dbFeed.Title,
		FetchedAt:    dbFeed.FetchedAt,
		IsSubscribed: dbFeed.IsSubscribed == 1,
	}, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	articleID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid article ID: %w", err)
	}

	row, err := r.Queries.GetArticle(ctx, db.GetArticleParams{
		ID:     articleID,
		UserID: userID,
	})
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("article not found")
		}
		return nil, fmt.Errorf("failed to query article: %w", err)
	}

	return &model.Article{
		ID:     strconv.FormatInt(row.ID, 10),
		FeedID: strconv.FormatInt(row.FeedID, 10),
		GUID:   row.Guid,
		Title:  row.Title,
		URL:    row.Url,
		IsRead: row.IsRead == 1,
		Feed: &model.Feed{
			ID:    strconv.FormatInt(row.FeedID2, 10),
			URL:   row.FeedUrl,
			Title: row.FeedTitle,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		// Not authenticated - return nil (not an error)
		return nil, nil
	}

	user, err := r.Queries.GetUserByID(ctx, userID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	return &model.User{
		ID:       strconv.FormatInt(user.ID, 10),
		Username: user.Username,
	}, nil
}

// Mutation returns gql.MutationResolver implementation.
func (r *Resolver) Mutation() gql.MutationResolver { return &mutationResolver{r} }

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
